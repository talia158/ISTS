4   Design
    4.1  High-Level Architecture
         • Two-tier overview (Figure 4-1: system container diagram)
    4.2  Design Rationale
         • Maintainability            →   stateless REST, two-tier split
         • Performance                →   GPU clustering, indirect draws, zero-copy buffers
         • Usability & Recursion      →   hierarchy-aware UI, single-keystroke gestures
         • Reproducibility & Security →   deterministic seeding, sandboxed heuristics
    4.3  Subsystem Decomposition
         • Backend service layer  
         • Simulation core (IC & LT engines)  
         • Data-exchange protocol  
         • Rendering & UI subsystem (SubGraph / SubGraphManager classes)
    4.4  GPU Rendering & Data Pipeline
         4.4.1  Flattened MessagePack “display blob”
         4.4.2  Indirect mesh rendering & compute-buffer residency
         4.4.3  On-GPU tint computation & shader-determined attributes
         4.4.4  Hierarchy-aware redraw for recursive cluster expansion
         4.4.5  Bit-packed edge-activation highlighting
         4.4.6  Spatial Queries: frustum-culled closest-node search
    4.5  Algorithms & Complexity Analysis
         • Louvain / Leiden GPU clustering  
         • Spring layout & circle-packing  
         • Multithreaded IC and LT steps  
         • generate_display_data and expand_node routines  
         • Complexity summary table
    4.6  User-Interface Design
         • Scene flow: Home, Configuration, Visualiser, Heuristic Editor, Performance Dashboard
    4.7  Requirement Traceability
         • Matrix linking requirements → design decisions
    4.8  Security & Determinism Measures
         • Heuristic sandbox, five-second wall timer  
         • Stateless endpoints & horizontal scaling  
         • SHA-1-derived simulation seeds
